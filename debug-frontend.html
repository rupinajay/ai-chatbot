<!DOCTYPE html>
<html>
<head>
    <title>Debug Frontend Chat</title>
    <style>
        body { font-family: monospace; padding: 20px; }
        .message { margin: 10px 0; padding: 10px; border: 1px solid #ccc; }
        .user { background: #e3f2fd; }
        .assistant { background: #f3e5f5; }
        .loading { background: #fff3e0; }
        .error { background: #ffebee; color: red; }
        .log { background: #f5f5f5; font-size: 12px; margin: 5px 0; padding: 5px; }
    </style>
</head>
<body>
    <h1>Chat Debug Tool</h1>
    <div>
        <input type="text" id="messageInput" placeholder="Type a message..." style="width: 300px;">
        <button onclick="sendMessage()">Send</button>
        <button onclick="clearMessages()">Clear</button>
    </div>
    
    <div id="messages"></div>
    <div id="logs"></div>

    <script>
        let messages = [];
        let currentChatId = 'debug-chat-' + Date.now();
        
        function log(message) {
            const logsDiv = document.getElementById('logs');
            const logDiv = document.createElement('div');
            logDiv.className = 'log';
            logDiv.textContent = new Date().toISOString() + ': ' + message;
            logsDiv.appendChild(logDiv);
            console.log(message);
        }
        
        function renderMessages() {
            const messagesDiv = document.getElementById('messages');
            messagesDiv.innerHTML = '';
            
            messages.forEach(msg => {
                const msgDiv = document.createElement('div');
                msgDiv.className = 'message ' + msg.role;
                
                let content = '';
                if (msg.parts) {
                    content = msg.parts.map(part => {
                        if (part.type === 'text') return part.text;
                        return JSON.stringify(part);
                    }).join(' ');
                } else {
                    content = JSON.stringify(msg);
                }
                
                msgDiv.innerHTML = `<strong>${msg.role}:</strong> ${content}`;
                messagesDiv.appendChild(msgDiv);
            });
        }
        
        function addMessage(message) {
            messages.push(message);
            renderMessages();
            log('Added message: ' + JSON.stringify(message));
        }
        
        function clearMessages() {
            messages = [];
            renderMessages();
            document.getElementById('logs').innerHTML = '';
            log('Messages cleared');
        }
        
        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const text = input.value.trim();
            if (!text) return;
            
            input.value = '';
            
            // Add user message
            const userMessage = {
                id: 'user-' + Date.now(),
                role: 'user',
                parts: [{ type: 'text', text: text }]
            };
            addMessage(userMessage);
            
            // Add loading message
            const loadingMessage = {
                id: 'loading-' + Date.now(),
                role: 'loading',
                parts: [{ type: 'text', text: 'Thinking...' }]
            };
            addMessage(loadingMessage);
            
            try {
                log('Sending request to /api/chat');
                
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        id: currentChatId,
                        message: userMessage,
                        selectedChatModel: 'chat-model',
                        selectedVisibilityType: 'private',
                    }),
                });
                
                log('Response status: ' + response.status);
                log('Response headers: ' + JSON.stringify(Object.fromEntries(response.headers.entries())));
                
                if (!response.ok) {
                    const errorText = await response.text();
                    log('Error response: ' + errorText);
                    messages.pop(); // Remove loading message
                    addMessage({
                        id: 'error-' + Date.now(),
                        role: 'error',
                        parts: [{ type: 'text', text: 'Error: ' + errorText }]
                    });
                    return;
                }
                
                // Remove loading message
                messages.pop();
                renderMessages();
                
                // Process stream
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                let assistantMessage = {
                    id: 'assistant-' + Date.now(),
                    role: 'assistant',
                    parts: [{ type: 'text', text: '' }]
                };
                
                let messageStarted = false;
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    log('Received chunk: ' + chunk);
                    
                    const lines = chunk.split('\\n');
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);
                            if (data === '[DONE]') {
                                log('Stream completed with [DONE]');
                                break;
                            } else if (data.trim()) {
                                try {
                                    const event = JSON.parse(data);
                                    log('Parsed event: ' + JSON.stringify(event));
                                    
                                    if (event.type === 'text-delta') {
                                        if (!messageStarted) {
                                            addMessage(assistantMessage);
                                            messageStarted = true;
                                        }
                                        
                                        // Update the assistant message
                                        assistantMessage.parts[0].text += event.delta || '';
                                        renderMessages();
                                    } else if (event.type === 'finish') {
                                        log('Stream finished');
                                    }
                                } catch (e) {
                                    log('Failed to parse event: ' + data);
                                }
                            }
                        }
                    }
                }
                
                if (!messageStarted) {
                    log('No message was started - adding empty response');
                    assistantMessage.parts[0].text = 'No response received';
                    addMessage(assistantMessage);
                }
                
            } catch (error) {
                log('Request failed: ' + error.message);
                messages.pop(); // Remove loading message
                addMessage({
                    id: 'error-' + Date.now(),
                    role: 'error',
                    parts: [{ type: 'text', text: 'Request failed: ' + error.message }]
                });
            }
        }
        
        // Allow Enter key to send message
        document.getElementById('messageInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        
        log('Debug tool loaded');
    </script>
</body>
</html>